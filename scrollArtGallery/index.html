<style>
  body {
    margin: 0;
    height: 200vh;
    display: flex;
    justify-content: center;
    align-items: center;
    background: beige;
  }
  .imgs-wrapper {
    overflow: hidden;
    width: 80vw;
    height: 30vh;
    position: relative;
  }
  .imgs {
    display: flex;
    position: absolute;
    left: 0;
    top: 0;
  }
  .imgs img {
    width: 15vw;
    margin: 0 0.5vw;
    transform-origin: center center;
    transition: transform 0.2s, filter 0.2s, opacity 0.2s;
  }
</style>

<div class="imgs-wrapper">
  <div class="imgs">
    <img src="https://picsum.photos/300/200?random=1" />
    <img src="https://picsum.photos/300/200?random=2" />
    <img src="https://picsum.photos/300/200?random=3" />
    <img src="https://picsum.photos/300/200?random=4" />
    <img src="https://picsum.photos/300/200?random=5" />
  </div>
</div>

<script>
  const imgContainer = document.querySelector(".imgs");
  let imgs = Array.from(imgContainer.querySelectorAll("img"));

  // 克隆图片，做无限循环
  imgContainer.append(...imgs.map((img) => img.cloneNode(true)));
  imgContainer.append(...imgs.map((img) => img.cloneNode(true)));
  imgs = Array.from(imgContainer.querySelectorAll("img"));

  const imgCount = imgs.length;
  const wrapper = document.querySelector(".imgs-wrapper");
  const singleWidth =
    imgs[0].offsetWidth +
    parseFloat(getComputedStyle(imgs[0]).marginLeft) +
    parseFloat(getComputedStyle(imgs[0]).marginRight);
  const totalWidth = singleWidth * imgCount;

  let position = -singleWidth * (imgCount / 3); // 初始显示中间组
  imgContainer.style.transform = `translateX(${position}px)`;

  let targetPos = position;
  let speed = 0;
  const damping = 0.1;

  // 核心效果：中心缩放 + 模糊 + 透明度
  function updateImgEffect() {
    const centerX = wrapper.clientWidth / 2;

    imgs.forEach((img) => {
      const imgRect = img.getBoundingClientRect();
      const imgCenter = imgRect.left + imgRect.width / 2;
      const distance = Math.abs(centerX - imgCenter);
      const ratio = Math.max(0, 1 - distance / (wrapper.clientWidth / 2));

      img.style.transform = `scale(${0.7 + 0.5 * ratio})`;
      img.style.opacity = `${0.4 + 0.6 * ratio}`;
      img.style.filter = `blur(${5 * (1 - ratio)}px)`;
    });
  }

  // 平滑动画循环
  function animate() {
    speed += (targetPos - position) * damping;
    speed *= 0.8;
    position += speed;

    // 无限循环逻辑
    if (position > 0) {
      position -= totalWidth / 3;
      targetPos -= totalWidth / 3;
    } else if (position < (-totalWidth * 2) / 3) {
      position += totalWidth / 3;
      targetPos += totalWidth / 3;
    }

    imgContainer.style.transform = `translateX(${position}px)`;
    updateImgEffect();
    requestAnimationFrame(animate);
  }
  animate();

  // 滚轮事件：纵向滚轮控制横向滚动
  let wheelTimeout;
  window.addEventListener(
    "wheel",
    (e) => {
      const delta = e.deltaY;
      targetPos -= delta; // 正数向下滚，translateX向左

      // 清除之前定时器
      if (wheelTimeout) clearTimeout(wheelTimeout);

      // 滚轮停止后触发吸附
      wheelTimeout = setTimeout(() => {
        snapToClosest();
      }, 150); // 150ms 无滚动则认为停止

      e.preventDefault();
    },
    { passive: false }
  );

  // 吸附到最近中心图片
  function snapToClosest() {
    const containerCenter = wrapper.clientWidth / 2;
    let closestImg = imgs[0];
    let minDist = Infinity;

    imgs.forEach((img) => {
      const rect = img.getBoundingClientRect();
      const imgCenter = rect.left + rect.width / 2;
      const dist = Math.abs(containerCenter - imgCenter);
      if (dist < minDist) {
        minDist = dist;
        closestImg = img;
      }
    });

    const imgRect = closestImg.getBoundingClientRect();
    const imgCenter = imgRect.left + imgRect.width / 2;
    targetPos += containerCenter - imgCenter; // 调整 targetPos，让最近图片居中
  }
</script>
